using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Exploit_SB147.Model
{
  class CycleSinus
  {
    //Variables public
    public string NomSinus;
    public double Amplitude;
    public double Fréquence;
    public double VitesseMax;
    public double ToleranceDetenteMin;
    public double ToleranceDetenteMax;
    public double ToleranceCompressionMin;
    public double ToleranceCompressionMax;
    public double[] Temps;
    public double[] Course;
    public double[] Effort;
    public double[] Vitesse;
    public int début=0;
    public int fin=0;
    public bool DetenteConforme;
    public bool CompressionConforme;

    //Variables privées
    private int NombreData;

    public void InitTableau()
    {
      NombreData = fin - début;
      Temps = new double[NombreData];
      Course = new double[NombreData];
      Effort = new double[NombreData];
      Vitesse = new double[NombreData];

    }
    public void CopieValeurs(double[,] tableau)
    {
      for(int i=0; i < NombreData; i++)
      {
        Temps[i] = tableau[i + début, 0];
        Course[i] = tableau[i + début, 1];
        Vitesse[i] = tableau[i + début, 2];
        Effort[i] = tableau[i + début, 3];
      }
    }

    public double EffortMax()
    {
      int TierNombreData = NombreData / 3;
      double EffortMaxTampon=0;
      double EffortMax = 0;
      for (int i = 0; i < 3; i++)
      {
        for(int k = i * TierNombreData; k < (1 + i) * TierNombreData; k++)
        {
          EffortMaxTampon = Math.Max(EffortMaxTampon, Effort[k]);
        }
        EffortMax = EffortMax + EffortMaxTampon;
      }
      EffortMax = EffortMax / 3;
      if (EffortMax>=ToleranceDetenteMin && EffortMax <= ToleranceDetenteMax)
      {
        DetenteConforme = true;
      }
      else
      {
        DetenteConforme = false;
      }
      return Math.Round(EffortMax);
    }

    public double EffortMin()
    {
      int TierNombreData = NombreData / 3;
      double EffortMinTampon = 0;
      double EffortMin = 0;
      for (int i = 0; i < 3; i++)
      {
        for (int k = i * TierNombreData; k < (1 + i) * TierNombreData; k++)
        {
          EffortMinTampon = Math.Min(EffortMinTampon, Effort[k]);
        }
        EffortMin = EffortMin + EffortMinTampon;
      }
      EffortMin = EffortMin / 3;
      if (EffortMin <= ToleranceCompressionMin && EffortMin >= ToleranceCompressionMax)
      {
        CompressionConforme = true;
      }
      else
      {
        CompressionConforme = false;
      }
      return Math.Round(EffortMin);
    }



  }
}
