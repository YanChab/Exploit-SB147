using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Exploit_SB147.Model
{
  class MesureImportee
  {
    #region Variables

    public string NomMesure;
    public int NombreLigne = 0;
    public double[,] MesuresBrutes;
    private string line;
    public double CourseOffset;
    public double EffortOfsset;
    public double[,] MesuresTraitees;// 0: temps, 1: course, 2: Vitesse, 3: effort 
    public double[] LEVMesure;
    public bool Conformite;
    public double OffsetConsigne;
    public double testOffsetConsigne;
    public List<CycleSinus> ListeSinus;
    public int NumeroSinus = 0;

    #endregion

    public void ImportationMesure(string fichier)
    {

      // On recherche le nombre de ligne et on inscrit chauqe ligne dans une liste
      StreamReader file = new StreamReader(fichier);
      List<string> ListeLigneFichier = new List<string>();
      while ((line = file.ReadLine()) != null) 
      {
        ListeLigneFichier.Add(line);
        NombreLigne++; 
      }
      // On limite le nombre de ligne
      if (NombreLigne > 44000)
      {
        NombreLigne = 44000;
      }


      // On recherche le nombre de colonne
      var Colonnes = ListeLigneFichier[0].Split(',');
      int nbrColonnes = Colonnes.Length;
      NomMesure = Path.GetFileNameWithoutExtension(fichier);
      MesuresBrutes = new double[NombreLigne - 1, nbrColonnes];
      MesuresTraitees = new double[NombreLigne - 1, nbrColonnes];
      for (int i = 1; i < NombreLigne-1; i++)
      {
        var ligne=ListeLigneFichier[i].Split(',');
        for (int j=0; j<nbrColonnes-1; j++)
        {
          MesuresBrutes[i, j] = Convert.ToDouble(ligne[j].Replace(".",","));
        }
        // On rempli la conne temps dans mesuresTraitees
        MesuresTraitees[i, 0] = MesuresBrutes[i, 0];
      }
      #region Calcul de l'offset de l'effort


      //On décale la consigne pour n'avoir que du positif
      for (int i = 1; i < NombreLigne - 1; i++)
      {
        MesuresBrutes[i, 5] = MesuresBrutes[i, 5] + 200.0;
      }
      //On recehrche l'offset qui correspond à la somme minimale
      double sumOffset;
      double sumOffsetSaved = 0;
      for (int i = 1; i < 4000; i++)
      {
        sumOffset = 0;
        for (int j = 6; j < NombreLigne - 6; j++)
        //for (int j = 1; j < 1000; j++)
        {
          if (Math.Abs(MesuresBrutes[j + 5, 5] - MesuresBrutes[j - 5, 5]) / 0.02 < 0.002)
          {
            sumOffset = Math.Abs(MesuresBrutes[j, 5] - i / 10) + sumOffset;
          }

        }
        if (i == 1)
        {
          sumOffsetSaved = (sumOffset);
        }
        else
        {

          if ((sumOffset) < sumOffsetSaved)
          {
            sumOffsetSaved = sumOffset;
            OffsetConsigne = i / 10 - 200;
          }
        }
      }
      //On décale la consigne pour n'avoir que du positif
      for (int i = 1; i < NombreLigne - 1; i++)
      {
        MesuresBrutes[i, 5] = MesuresBrutes[i, 5] - 200.0;
      }


      //On cherche l'offset sur l'effort
      int Debut = 0;
      int Fin = 0;
      double MaxMoyenne = OffsetConsigne+0.1;
      double MinMoyenne = OffsetConsigne-0.1;
      //double MaxMoyenne = -29.9;
      //double MinMoyenne = -30.1;
      //double VitesseMoyenne = 0;

      EffortOfsset = 0;
      for (int i = 10000; i < NombreLigne - 501; i++)
      {
        double Moyenne = 0;
        //description : on fait la moyenne sur les 500 valeurs précédentes. pour être sur de se placer sur le plateau de la pause et on fait la moyenne de l'effort sur 1 seconde
        for (int j=-500; j < 00; j++)
        {
          //VitesseMoyenne = (MesuresBrutes[i + j, 5] - MesuresBrutes[i + j - 2, 5]) / (MesuresBrutes[i + j, 1] - MesuresBrutes[i + j - 2, 1]);
          //On itère sur la consigne
          //Moyenne = Moyenne + VitesseMoyenne;
          Moyenne = Moyenne + MesuresBrutes[i + j, 5];
        }
        Moyenne = Moyenne / 500;
        //if (Moyenne > -2 && Moyenne < 2 && Debut == 0)
        if (Moyenne>MinMoyenne && Moyenne < MaxMoyenne && Debut==0)
        {
          Debut = i;
          Fin = Debut + 500;
          break;
        }
        
      }
      //On calcul la moyenne de l'effort
      for(int i = Debut; i < Fin; i++)
      {
        //EffortOfsset = EffortOfsset + MesuresBrutes[i, 4];
        CourseOffset = CourseOffset + MesuresBrutes[i, 1];
      }
      //EffortOfsset = -EffortOfsset / (Fin - Debut);
      CourseOffset = -CourseOffset / (Fin - Debut);

      for (int i = NombreLigne-500; i < NombreLigne - 100; i++)
      {
        EffortOfsset = EffortOfsset + MesuresBrutes[i, 4];
        
      }
      EffortOfsset = -EffortOfsset / (400);
      //Calcul de l'offset consigne





      #endregion

      #region Retraitement des mesures
      // Filtration et offset pour calculer les mesures traitées
      //On applique l'offset à la course et a l'effort
      for (int i = 1; i < NombreLigne - 1; i++)
      {
        MesuresTraitees[i, 1] = MesuresBrutes[i, 1] + CourseOffset+74/2;
        MesuresTraitees[i, 3] = (MesuresBrutes[i, 4] + EffortOfsset)*1000;
      }
      for (int i = 3; i < NombreLigne - 1; i++)
      {
        double f = 50;
        double Pi = Math.PI;
        double Dt = MesuresTraitees[i, 0] - MesuresTraitees[i - 1, 0];
        MesuresTraitees[i, 1] = (2 * (1 + 0.7 * 2 * Pi * f * Dt) * MesuresTraitees[i - 1, 1] - MesuresTraitees[i - 2, 1] + Math.Pow(2 * Pi * f * Dt, 2) * MesuresTraitees[i, 1]) / (1 + Math.Pow(2 * Pi * f * Dt, 2) + 2 * 0.7 * 2 * Pi * f * Dt);
        MesuresTraitees[i, 3] = (2 * (1 + 0.7 * 2 * Pi * f * Dt) * MesuresTraitees[i - 1, 3] - MesuresTraitees[i - 2, 3] + Math.Pow(2 * Pi * f * Dt, 2) * MesuresTraitees[i, 3]) / (1 + Math.Pow(2 * Pi * f * Dt, 2) + 2 * 0.7 * 2 * Pi * f * Dt);
        MesuresTraitees[i, 2] = (MesuresTraitees[i, 1] - MesuresTraitees[i - 1, 1]) / (MesuresTraitees[i, 0] - MesuresTraitees[i - 1, 0]);
        
      }



      #endregion

      #region Récupération des différents sinus

      MaxMoyenne = 74 / 2+0.2;
      MinMoyenne = 74 / 2 - 0.2;
      bool RechercheFin = false;
      ListeSinus = new List<CycleSinus>();
      

      // On parcours tous la course
      for (int i = 1000; i < NombreLigne - 1001; i++)
      {
        double MoyennePre = 0;
        double MoyenneSui = 0;
        for (int j = -1000; j < 00; j++)
          {
          //On itère sur la course traitées
          MoyennePre = MoyennePre + MesuresTraitees[i + j, 1];
          }
        MoyennePre = MoyennePre / 1000;
        
          for (int j = 0; j < 1000; j++)
          {
          //On itère sur la course traitées
          MoyenneSui = MoyenneSui + MesuresTraitees[i + j, 1];
          }
        MoyenneSui = MoyenneSui / 1000;
        
        MesuresBrutes[i, 8] = MoyennePre;
        MesuresBrutes[i, 7] = MoyenneSui;
        if (MoyennePre < MaxMoyenne && MoyennePre > MinMoyenne && MoyenneSui < MinMoyenne && !RechercheFin)
        {
          RechercheFin = true;
          ListeSinus.Add(new CycleSinus() { NomSinus = "Sinus " + (NumeroSinus+1).ToString(), début=i });          
        }
        else if (MoyenneSui < MaxMoyenne && MoyenneSui > MinMoyenne && MoyennePre < MinMoyenne && i>10000 && !RechercheFin && NumeroSinus==0)
        {
          ListeSinus.Add(new CycleSinus() { NomSinus = "Sinus " + (NumeroSinus + 1).ToString(), début = i });
          ListeSinus[NumeroSinus].fin = i + 100;
          ListeSinus[NumeroSinus].début = ListeSinus[NumeroSinus].fin - 17000;
          ListeSinus[NumeroSinus].InitTableau();
          ListeSinus[NumeroSinus].CopieValeurs(MesuresTraitees);
          NumeroSinus = NumeroSinus + 1;
        }
        else if (MoyenneSui < MaxMoyenne && MoyenneSui > MinMoyenne && MoyennePre < MinMoyenne && RechercheFin)
        {
          RechercheFin = false;
          ListeSinus[NumeroSinus].fin = i+100;          
          ListeSinus[NumeroSinus].InitTableau();
          ListeSinus[NumeroSinus].CopieValeurs(MesuresTraitees);
          NumeroSinus = NumeroSinus + 1;
        }
        

      }
      
      #endregion
    }

    public void CalculLEV()
    {
      LEVMesure = new double[ListeSinus.Count * 2 + 1];
      for (int i = 0; i < ListeSinus.Count; i++)
      {
        LEVMesure[ListeSinus.Count - 1 - i] = ListeSinus[i].EffortMin();
        LEVMesure[ListeSinus.Count * 2 - i] = ListeSinus[ListeSinus.Count - 1 - i].EffortMax();
      }
      LEVMesure[ListeSinus.Count] = 0;
    }
    



    




  }
}
